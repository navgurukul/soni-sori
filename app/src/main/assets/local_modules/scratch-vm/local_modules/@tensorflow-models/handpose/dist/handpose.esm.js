/**
    * @license
    * Copyright 2020 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */
import{util,Tensor,tidy,browser,tensor2d,tensor1d,slice,add,div,mul,sub,concat2d,env,sigmoid,image,getBackend,reshape,backend,buffer}from"@tensorflow/tfjs-core";import{loadGraphModel}from"@tensorflow/tfjs-converter";function getBoxSize(t){return[Math.abs(t.endPoint[0]-t.startPoint[0]),Math.abs(t.endPoint[1]-t.startPoint[1])]}function getBoxCenter(t){return[t.startPoint[0]+(t.endPoint[0]-t.startPoint[0])/2,t.startPoint[1]+(t.endPoint[1]-t.startPoint[1])/2]}function cutBoxFromImageAndResize(t,n,e){const o=n.shape[1],s=n.shape[2],i=[[t.startPoint[1]/o,t.startPoint[0]/s,t.endPoint[1]/o,t.endPoint[0]/s]];return image.cropAndResize(n,i,[0],e)}function scaleBoxCoordinates(t,n){return{startPoint:[t.startPoint[0]*n[0],t.startPoint[1]*n[1]],endPoint:[t.endPoint[0]*n[0],t.endPoint[1]*n[1]],palmLandmarks:t.palmLandmarks.map(t=>{return[t[0]*n[0],t[1]*n[1]]})}}function enlargeBox(t,n=1.5){const e=getBoxCenter(t),o=getBoxSize(t),s=[n*o[0]/2,n*o[1]/2];return{startPoint:[e[0]-s[0],e[1]-s[1]],endPoint:[e[0]+s[0],e[1]+s[1]],palmLandmarks:t.palmLandmarks}}function squarifyBox(t){const n=getBoxCenter(t),e=getBoxSize(t),o=Math.max(...e)/2;return{startPoint:[n[0]-o,n[1]-o],endPoint:[n[0]+o,n[1]+o],palmLandmarks:t.palmLandmarks}}function shiftBox(t,n){const e=[t.endPoint[0]-t.startPoint[0],t.endPoint[1]-t.startPoint[1]],o=[e[0]*n[0],e[1]*n[1]];return{startPoint:[t.startPoint[0]+o[0],t.startPoint[1]+o[1]],endPoint:[t.endPoint[0]+o[0],t.endPoint[1]+o[1]],palmLandmarks:t.palmLandmarks}}class HandDetector{constructor(t,n,e,o,s,i){this.model=t,this.width=n,this.height=e,this.iouThreshold=s,this.scoreThreshold=i,this.anchors=o.map(t=>[t.x_center,t.y_center]),this.anchorsTensor=tensor2d(this.anchors),this.inputSizeTensor=tensor1d([n,e]),this.doubleInputSizeTensor=tensor1d([2*n,2*e])}normalizeBoxes(t){return tidy(()=>{const n=slice(t,[0,0],[-1,2]),e=slice(t,[0,2],[-1,2]),o=add(div(n,this.inputSizeTensor),this.anchorsTensor),s=div(e,this.doubleInputSizeTensor),i=mul(sub(o,s),this.inputSizeTensor),r=mul(add(o,s),this.inputSizeTensor);return concat2d([i,r],1)})}normalizeLandmarks(t,n){return tidy(()=>{const e=add(div(t.reshape([-1,7,2]),this.inputSizeTensor),this.anchors[n]);return mul(e,this.inputSizeTensor)})}getBoundingBoxes(t){return tidy(()=>{const n=mul(sub(t,.5),2),e=env().get("WEBGL_PACK_DEPTHWISECONV");env().set("WEBGL_PACK_DEPTHWISECONV",!0);const o=this.model.predict(n).squeeze();env().set("WEBGL_PACK_DEPTHWISECONV",e);const s=sigmoid(slice(o,[0,0],[-1,1])).squeeze(),i=slice(o,[0,1],[-1,4]),r=this.normalizeBoxes(i),a=console.warn;console.warn=(()=>{});const d=image.nonMaxSuppression(r,s,1,this.iouThreshold,this.scoreThreshold).arraySync();if(console.warn=a,0===d.length)return null;const u=d[0],c=slice(r,[u,0],[1,-1]),h=slice(o,[u,5],[1,14]);return{boxes:c,palmLandmarks:this.normalizeLandmarks(h,u).reshape([-1,2])}})}estimateHandBounds(t){const n=t.shape[1],e=t.shape[2],o=tidy(()=>t.resizeBilinear([this.width,this.height]).div(255)),s=this.getBoundingBoxes(o);if(null===s)return o.dispose(),null;const i=s.boxes.arraySync(),r=i[0].slice(0,2),a=i[0].slice(2,4),d=s.palmLandmarks.arraySync();return o.dispose(),s.boxes.dispose(),s.palmLandmarks.dispose(),scaleBoxCoordinates({startPoint:r,endPoint:a,palmLandmarks:d},[e/this.width,n/this.height])}}const MESH_ANNOTATIONS={thumb:[1,2,3,4],indexFinger:[5,6,7,8],middleFinger:[9,10,11,12],ringFinger:[13,14,15,16],pinky:[17,18,19,20],palmBase:[0]};function rotate(t,n,e,o){const s=backend(),i=buffer(t.shape,t.dtype),[r,a,d,u]=t.shape,c=d*("number"==typeof o?o:o[0]),h=a*("number"==typeof o?o:o[1]),l=Math.sin(-n),m=Math.cos(-n),p=s.readSync(t.dataId);for(let t=0;t<r;t++)for(let n=0;n<a;n++)for(let o=0;o<d;o++)for(let s=0;s<u;s++){const f=[r,n,o,s],_=f[2],P=f[1];let g=(_-c)*m-(P-h)*l,M=(_-c)*l+(P-h)*m;g=Math.round(g+c),M=Math.round(M+h);let T=e;if("number"!=typeof e&&(T=3===s?255:e[s]),g>=0&&g<d&&M>=0&&M<a){T=p[t*d*a*u+M*(d*u)+g*u+s]}const I=t*d*a*u+n*(d*u)+o*u+s;i.values[I]=T}return i.toTensor()}function rotate$1(t,n,e,o){const s=t.shape,i=s[1],r=s[2],a=Math.sin(n),d=Math.cos(n),u=Math.floor(r*("number"==typeof o?o:o[0])),c=Math.floor(i*("number"==typeof o?o:o[1]));let h="";const l={variableNames:["Image"],outputShape:s,userCode:`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int x = coords[2];\n        int y = coords[1];\n        int coordX = int(float(x - ${u}) * ${d} -\n          float(y - ${c}) * ${a});\n        int coordY = int(float(x - ${u}) * ${a} +\n          float(y - ${c}) * ${d});\n        coordX = int(coordX + ${u});\n        coordY = int(coordY + ${c});\n\n        ${h="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n      vec3 fill = vec3(${e.join(",")});\n      float outputValue = fill[coords[3]];`}\n\n        if(coordX > 0 && coordX < ${r} && coordY > 0 && coordY < ${i}) {\n          outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n        }\n\n      setOutput(outputValue);\n    }`};return backend().compileAndRun(l,[t])}function normalizeRadians(t){return t-2*Math.PI*Math.floor((t+Math.PI)/(2*Math.PI))}function computeRotation(t,n){return normalizeRadians(Math.PI/2-Math.atan2(-(n[1]-t[1]),n[0]-t[0]))}const buildTranslationMatrix=(t,n)=>[[1,0,t],[0,1,n],[0,0,1]];function dot(t,n){let e=0;for(let o=0;o<t.length;o++)e+=t[o]*n[o];return e}function getColumnFrom2DArr(t,n){const e=[];for(let o=0;o<t.length;o++)e.push(t[o][n]);return e}function multiplyTransformMatrices(t,n){const e=[],o=t.length;for(let s=0;s<o;s++){e.push([]);for(let i=0;i<o;i++)e[s].push(dot(t[s],getColumnFrom2DArr(n,i)))}return e}function buildRotationMatrix(t,n){const e=Math.cos(t),o=Math.sin(t),s=[[e,-o,0],[o,e,0],[0,0,1]];return multiplyTransformMatrices(multiplyTransformMatrices(buildTranslationMatrix(n[0],n[1]),s),buildTranslationMatrix(-n[0],-n[1]))}function invertTransformMatrix(t){const n=[[t[0][0],t[1][0]],[t[0][1],t[1][1]]],e=[t[0][2],t[1][2]],o=[-dot(n[0],e),-dot(n[1],e)];return[n[0].concat(o[0]),n[1].concat(o[1]),[0,0,1]]}function rotatePoint(t,n){return[dot(t,n[0]),dot(t,n[1])]}const UPDATE_REGION_OF_INTEREST_IOU_THRESHOLD=.8,PALM_BOX_SHIFT_VECTOR=[0,-.4],PALM_BOX_ENLARGE_FACTOR=3,HAND_BOX_SHIFT_VECTOR=[0,-.1],HAND_BOX_ENLARGE_FACTOR=1.65,PALM_LANDMARK_IDS=[0,5,9,13,17,1,2],PALM_LANDMARKS_INDEX_OF_PALM_BASE=0,PALM_LANDMARKS_INDEX_OF_MIDDLE_FINGER_BASE=2;class HandPipeline{constructor(t,n,e,o,s,i){this.regionsOfInterest=[],this.runsWithoutHandDetector=0,this.boundingBoxDetector=t,this.meshDetector=n,this.maxContinuousChecks=s,this.detectionConfidence=i,this.meshWidth=e,this.meshHeight=o,this.maxHandsNumber=1}getBoxForPalmLandmarks(t,n){const e=t.map(t=>{return rotatePoint([...t,1],n)});return enlargeBox(squarifyBox(shiftBox(this.calculateLandmarksBoundingBox(e),PALM_BOX_SHIFT_VECTOR)),PALM_BOX_ENLARGE_FACTOR)}getBoxForHandLandmarks(t){const n=enlargeBox(squarifyBox(shiftBox(this.calculateLandmarksBoundingBox(t),HAND_BOX_SHIFT_VECTOR)),HAND_BOX_ENLARGE_FACTOR),e=[];for(let n=0;n<PALM_LANDMARK_IDS.length;n++)e.push(t[PALM_LANDMARK_IDS[n]].slice(0,2));return n.palmLandmarks=e,n}transformRawCoords(t,n,e,o){const s=getBoxSize(n),i=[s[0]/this.meshWidth,s[1]/this.meshHeight],r=t.map(t=>[i[0]*(t[0]-this.meshWidth/2),i[1]*(t[1]-this.meshHeight/2),t[2]]),a=buildRotationMatrix(e,[0,0]),d=r.map(t=>{return[...rotatePoint(t,a),t[2]]}),u=invertTransformMatrix(o),c=[...getBoxCenter(n),1],h=[dot(c,u[0]),dot(c,u[1])];return d.map(t=>[t[0]+h[0],t[1]+h[1],t[2]])}async estimateHand(t){const n=this.shouldUpdateRegionsOfInterest();if(!0===n){const n=this.boundingBoxDetector.estimateHandBounds(t);if(null===n)return t.dispose(),this.regionsOfInterest=[],null;this.updateRegionsOfInterest(n,!0),this.runsWithoutHandDetector=0}else this.runsWithoutHandDetector++;const e=this.regionsOfInterest[0],o=computeRotation(e.palmLandmarks[PALM_LANDMARKS_INDEX_OF_PALM_BASE],e.palmLandmarks[PALM_LANDMARKS_INDEX_OF_MIDDLE_FINGER_BASE]),s=getBoxCenter(e),i=[s[0]/t.shape[2],s[1]/t.shape[1]];let r;const a=getBackend();if("webgl"===a)r=rotate$1(t,o,0,i);else{if("cpu"!==a)throw new Error(`Handpose is not yet supported by the ${a} `+"backend - rotation kernel is not defined.");r=rotate(t,o,0,i)}const d=buildRotationMatrix(-o,s);let u;const c=cutBoxFromImageAndResize(u=!0===n?this.getBoxForPalmLandmarks(e.palmLandmarks,d):e,r,[this.meshWidth,this.meshHeight]),h=c.div(255);c.dispose(),r.dispose();const l=env().get("WEBGL_PACK_DEPTHWISECONV");env().set("WEBGL_PACK_DEPTHWISECONV",!0);const[m,p]=this.meshDetector.predict(h);env().set("WEBGL_PACK_DEPTHWISECONV",l),h.dispose();const f=m.dataSync()[0];if(m.dispose(),f<this.detectionConfidence)return p.dispose(),this.regionsOfInterest=[],null;const _=reshape(p,[-1,3]),P=_.arraySync();p.dispose(),_.dispose();const g=this.transformRawCoords(P,u,o,d),M=this.getBoxForHandLandmarks(g);return this.updateRegionsOfInterest(M,!1),{landmarks:g,handInViewConfidence:f,boundingBox:{topLeft:M.startPoint,bottomRight:M.endPoint}}}calculateLandmarksBoundingBox(t){const n=t.map(t=>t[0]),e=t.map(t=>t[1]);return{startPoint:[Math.min(...n),Math.min(...e)],endPoint:[Math.max(...n),Math.max(...e)]}}updateRegionsOfInterest(t,n){if(n)this.regionsOfInterest=[t];else{const n=this.regionsOfInterest[0];let e=0;if(null!=n&&null!=n.startPoint){const[o,s]=t.startPoint,[i,r]=t.endPoint,[a,d]=n.startPoint,[u,c]=n.endPoint,h=Math.max(o,a),l=Math.max(s,d),m=(Math.min(i,u)-h)*(Math.min(r,c)-l);e=m/((i-o)*(r-s)+(u-a)*(c-s)-m)}this.regionsOfInterest[0]=e>UPDATE_REGION_OF_INTEREST_IOU_THRESHOLD?n:t}}shouldUpdateRegionsOfInterest(){return this.regionsOfInterest.length!==this.maxHandsNumber||this.runsWithoutHandDetector>=this.maxContinuousChecks}}async function loadHandDetectorModel(){return loadGraphModel("https://tfhub.dev/mediapipe/tfjs-model/handdetector/1/default/1",{fromTFHub:!0})}const MESH_MODEL_INPUT_WIDTH=256,MESH_MODEL_INPUT_HEIGHT=256;async function loadHandPoseModel(){return loadGraphModel("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1",{fromTFHub:!0})}async function loadAnchors(){return util.fetch("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1/anchors.json?tfjs-format=file").then(t=>t.json())}async function load({maxContinuousChecks:t=1/0,detectionConfidence:n=.8,iouThreshold:e=.3,scoreThreshold:o=.5}={}){const[s,i,r]=await Promise.all([loadAnchors(),loadHandDetectorModel(),loadHandPoseModel()]),a=new HandDetector(i,MESH_MODEL_INPUT_WIDTH,MESH_MODEL_INPUT_HEIGHT,s,e,o),d=new HandPipeline(a,r,MESH_MODEL_INPUT_WIDTH,MESH_MODEL_INPUT_HEIGHT,t,n);return new HandPose(d)}function getInputTensorDimensions(t){return t instanceof Tensor?[t.shape[0],t.shape[1]]:[t.height,t.width]}function flipHandHorizontal(t,n){const{handInViewConfidence:e,landmarks:o,boundingBox:s}=t;return{handInViewConfidence:e,landmarks:o.map(t=>[n-1-t[0],t[1],t[2]]),boundingBox:{topLeft:[n-1-s.topLeft[0],s.topLeft[1]],bottomRight:[n-1-s.bottomRight[0],s.bottomRight[1]]}}}class HandPose{constructor(t){this.pipeline=t}static getAnnotations(){return MESH_ANNOTATIONS}async estimateHands(t,n=!1){const[,e]=getInputTensorDimensions(t),o=tidy(()=>(t instanceof Tensor||(t=browser.fromPixels(t)),t.toFloat().expandDims(0))),s=await this.pipeline.estimateHand(o);if(o.dispose(),null===s)return[];let i=s;!0===n&&(i=flipHandHorizontal(s,e));const r={};for(const t of Object.keys(MESH_ANNOTATIONS))r[t]=MESH_ANNOTATIONS[t].map(t=>i.landmarks[t]);return[{handInViewConfidence:i.handInViewConfidence,boundingBox:i.boundingBox,landmarks:i.landmarks,annotations:r}]}}export{load,HandPose};
